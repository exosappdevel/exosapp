import React, { useEffect, useState, useContext } from "react";
import {
  View,
  Text,
  FlatList,
  TouchableOpacity,
  StyleSheet,
  Modal,
  TextInput,
  ActivityIndicator,
  Alert,
  Platform,
} from "react-native";
import { SafeAreaView } from "react-native-safe-area-context";
import { MaterialCommunityIcons } from "@expo/vector-icons";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { AppContext } from "../context/AppContext";
import ApiService from "../services/ApiServices";
import { calcularPrioridad } from "../utils/PickeoUtils";

export default function PickeoScreen({ navigation, route }) {
  const { user, theme } = useContext(AppContext);
  const inputRef = React.useRef(null);
  const [productos, setProductos] = useState([]);
  const [loading, setLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [mostrarCompletos, setMostrarCompletos] = useState(true);
  const [sortBy, setSortBy] = useState("prioridad");
  const [modalCant, setModalCant] = useState({
    visible: false,
    item: null,
    cantidad: "1",
    esResta: false,
  });

  const id_terminal = route.params?.id_terminal;
  const terminal_nombre = route.params?.terminal_nombre;
  const STORAGE_KEY = `@pickeo_storage_term_${id_terminal}`;

  useEffect(() => {
    inicializarDatos(true);
  }, [id_terminal]);
  useEffect(() => {
    if (modalCant.visible) {
      // Usamos un pequeño delay para esperar a que el Modal esté 100% montado
      setTimeout(() => {
        if (inputRef.current) {
          inputRef.current.focus();
          // En Web necesitamos forzar la selección manual
          if (Platform.OS === 'web') {
            inputRef.current.setSelectionRange(0, modalCant.cantidad.length);
          }
        }
      }, 150);
    }
  }, [modalCant.visible]);

  const inicializarDatos = async (sync_server) => {
    try {
      setLoading(true);
      // 1. Intentar cargar progreso local
      const savedData = await AsyncStorage.getItem(STORAGE_KEY);
      let listaLocal = savedData ? JSON.parse(savedData) : [];

      

      // Validar si la respuesta es una lista o un objeto único
      let listaWS = [];
      if (sync_server){
        // 2. Llamada al WebService
        const dataWS = await ApiService.get_pickeo_list(user.id_usuario, id_terminal);
        if (Array.isArray(dataWS)) {
          listaWS = dataWS;
        } else if (dataWS && typeof dataWS === "object" && !dataWS.result) {
          listaWS = [dataWS];
        }
      }

      // 3. Cruzar datos: Mandan los campos del WS pero respetamos la cantidad recolectada local
      const listaFinal = listaWS.map((pWS) => {
        const id = pWS.id || pWS.id_producto || `p-${Math.random()}`;
        const localMatch = listaLocal.find(
          (l) => (l.id || l.id_producto) === id,
        );

        const recolectada = localMatch
          ? localMatch.cantidad_recolectada
          : parseInt(pWS.cantidad_recolectada || 0);
        const solicitada = parseInt(pWS.cantidad_solicitada || 0);

        return {
          ...pWS,
          id,
          cantidad_recolectada: recolectada,
          cantidad_solicitada: solicitada,
          ...calcularPrioridad(solicitada, recolectada),
        };
      });

      setProductos(listaFinal);
      await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(listaFinal));
    } catch (e) {
      console.error("Error inicializando lista:", e);
      Alert.alert(
        "Error",
        "No se pudieron obtener los productos del servidor.",
      );
    } finally {
      setLoading(false);
    }
  };

  const aplicarPick = async (item, cantStr, esResta) => {
    const valor = parseInt(cantStr) || 0;
    const nuevaLista = productos.map((p) => {
      if (p.id === item.id) {
        const nuevaReco = esResta
          ? Math.max(0, p.cantidad_recolectada - valor)
          : p.cantidad_recolectada + valor;
        return {
          ...p,
          cantidad_recolectada: nuevaReco,
          ...calcularPrioridad(p.cantidad_solicitada, nuevaReco),
        };
      }
      return p;
    });
    setProductos(nuevaLista);
    await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(nuevaLista));
    setModalCant({ visible: false, item: null, cantidad: "1", esResta: false });
  };


  const handleCheckOut = async () => {
    const confirmarEnvio = async () => {
      try {
        setIsSubmitting(true);
        const res = await ApiService.pickeo_checkout(user.id_usuario, id_terminal, productos);
        setIsSubmitting(false);

        // 1. Extraer el mensaje
        const mensaje = res?.result_text || "Error desconocido";
        const esExito = res?.result === "ok";

        // 2. Ejecutar la alerta
        if (Platform.OS === "web") {
          // En web, Alert.alert a veces falla, usamos el alert del navegador
          window.alert(esExito ? `Éxito: ${mensaje}` : `Aviso: ${mensaje}`);
          if (esExito) {
            await AsyncStorage.removeItem(STORAGE_KEY);
            inicializarDatos(false);
          }
        } else {
          // En móvil, usamos la API de React Native
          Alert.alert(esExito ? "Éxito" : "Aviso", mensaje, [
            { text: "OK", onPress: () => esExito && inicializarDatos(false) },
          ]);
        }
      } catch (e) {
        setIsSubmitting(false);
        const errorMsg = "No se pudo conectar con el servidor.";
        Platform.OS === "web"
          ? window.alert(errorMsg)
          : Alert.alert("Error", errorMsg);
      }
    };
    if (Platform.OS === "web") {
      if (window.confirm("¿Realizar Check Out de la terminal?"))
        confirmarEnvio();
    } else {
      Alert.alert("Check Out", "¿Realizar Check Out de la terminal?", [
        { text: "No" },
        { text: "Sí", onPress:
          confirmarEnvio 
        },
      ]);
    }
  };

  const listaRender = productos
    .filter((p) => mostrarCompletos || p.faltante > 0)
    .sort((a, b) => {
      if (sortBy === "prioridad") return a.prioridad - b.prioridad;
      return (a.referencia || "").localeCompare(b.referencia || "");
    });

  return (
    <SafeAreaView style={[styles.container, { backgroundColor: theme.bg }]}>
      <View style={[styles.header, { borderBottomColor: theme.border }]}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <MaterialCommunityIcons
            name="arrow-left"
            size={28}
            color={theme.text}
          />
        </TouchableOpacity>
        <Text style={[styles.title, { color: theme.text }]}>
          {user.almacen_codigo} - {terminal_nombre}
        </Text>
        <TouchableOpacity
          onPress={() => inicializarDatos(true)
          }
        >
          <MaterialCommunityIcons
            name={"refresh"
            }
            size={24}
            color="#3182ce"
            style={styles.refresh_icon}
          />
        </TouchableOpacity>
        <TouchableOpacity
          onPress={() =>
            setSortBy(sortBy === "prioridad" ? "referencia" : "prioridad")
          }
        >
          <MaterialCommunityIcons
            name={
              sortBy === "prioridad"
                ? "sort-numeric-ascending"
                : "sort-alphabetical-ascending"
            }
            size={24}
            color="#3182ce"
          />
        </TouchableOpacity>
      </View>

      {loading ? (
        <ActivityIndicator size="large" color="#3182ce" style={{ flex: 1 }} />
      ) : (
        <FlatList
          data={listaRender}
          keyExtractor={(item) => item.id.toString()}
          renderItem={({ item }) => (
            <View
              style={[
                styles.itemRow,
                { backgroundColor: theme.card, borderColor: theme.border },
              ]}
            >
              <View style={[styles.dot, { backgroundColor: item.color }]} />
              <View style={{ flex: 1 }}>
                <Text style={[styles.textMain, { color: theme.text }]}>
                  {item.descripcion}
                </Text>
                <Text style={styles.textSub}>{item.referencia}</Text>
                <Text style={[styles.textStatus, { color: item.color }]}>
                  {item.cantidad_recolectada} / {item.cantidad_solicitada}
                </Text>
              </View>
              <View style={styles.actionsContainer}>
                <TouchableOpacity
                  onPress={(e) => {
                    if (Platform.OS === 'web') e.currentTarget.blur();
                    aplicarPick(item, "1", false)
                  }}
                  style={styles.btnQuick}
                >
                  <MaterialCommunityIcons
                    name="flash"
                    size={24}
                    color={item.color}
                  />
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.btnAction, { backgroundColor: item.color }]}
                  onPress={() =>
                    setModalCant({
                      visible: true,
                      item,
                      cantidad: "1",
                      esResta: false,
                    })
                  }
                >
                  <MaterialCommunityIcons name="plus" size={20} color="white" />
                </TouchableOpacity>
                <TouchableOpacity
                  style={[
                    styles.btnAction,
                    { backgroundColor: item.color, marginLeft: 8 },
                  ]}
                  onPress={() => {
                    if (Platform.OS === 'web') {
                      document.activeElement?.blur();
                    }
                    setModalCant({
                      visible: true,
                      item,
                      cantidad: "1",
                      esResta: true,
                    });
                  }
                  }
                >
                  <MaterialCommunityIcons
                    name="minus"
                    size={20}
                    color="white"
                  />
                </TouchableOpacity>
              </View>
            </View>
          )}
        />
      )}

      <View style={styles.footer}>
        <TouchableOpacity
          style={[styles.footerBtn, { backgroundColor: "#4a5568" }]}
          onPress={() => setMostrarCompletos(!mostrarCompletos)}
        >
          <Text style={styles.footerBtnText}>
            {mostrarCompletos ? "Oculta completos" : "Ver todos"}
          </Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.footerBtn, { backgroundColor: "#48bb78" }]}
          onPress={handleCheckOut}
          disabled={isSubmitting}
        >{isSubmitting ? (
          <ActivityIndicator color="white" />
        ) : (
          <View style={{ flexDirection: "row", alignItems: "center" }}>
            <MaterialCommunityIcons
              name="cart-variant"
              size={20}
              color="white"
              style={{ marginRight: 8 }}
            />
            <Text style={styles.footerBtnText}>Hacer Corte</Text>
          </View>
        )}
        </TouchableOpacity>
      </View>

      <Modal visible={modalCant.visible}
        transparent={true}
        animationType="none" // Cambiado de 'fade' a 'none' para evitar el bug de aria-hidden
        ariaHideApp={false}  // Propiedad crucial para evitar el error de accesibilidad
        onRequestClose={() => setModalCant({ ...modalCant, visible: false })}
      >
        <View style={styles.modalOverlay}>
          <View style={[styles.modalContent, { backgroundColor: theme.card }]}>
            <Text style={[styles.modalTitle, { color: theme.text }]}>
              Ajustar Cantidad
            </Text>
            <TextInput
              style={[
                styles.modalInput,
                {
                  backgroundColor: theme.bg,
                  color: theme.text,
                  borderColor: theme.border,
                },
              ]}
              ref={inputRef}
              keyboardType="numeric"
              value={modalCant.cantidad}
              onChangeText={(t) => setModalCant({ ...modalCant, cantidad: t })}
              autoFocus={true} // Esto asegura que el teclado se abra solo
              selectTextOnFocus={true}
            />
            <View style={styles.modalActions}>
              <TouchableOpacity
                onPress={() => setModalCant({ ...modalCant, visible: false })}
              >
                <Text style={{ color: theme.textSub, marginRight: 25 }}>
                  CANCELAR
                </Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[
                  styles.btnConfirm,
                  { backgroundColor: modalCant.item?.color || "#3182ce" },
                ]}
                onPress={() =>
                  aplicarPick(
                    modalCant.item,
                    modalCant.cantidad,
                    modalCant.esResta,
                  )
                }
              >
                <Text style={{ color: "white", fontWeight: "bold" }}>
                  ACEPTAR
                </Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1 },
  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    padding: 20,
    borderBottomWidth: 1,
  },
  title: { fontSize: 18, fontWeight: "bold" },
  itemRow: {
    flexDirection: "row",
    alignItems: "center",
    marginHorizontal: 15,
    marginBottom: 10,
    padding: 15,
    borderRadius: 12,
    borderWidth: 1,
  },
  dot: { width: 12, height: 12, borderRadius: 6, marginRight: 15 },
  textMain: { fontWeight: "bold", fontSize: 14 },
  textSub: { fontSize: 12, color: "#888" },
  textStatus: { fontSize: 13, fontWeight: "bold", marginTop: 4 },
  actionsContainer: { flexDirection: "row", alignItems: "center" },
  btnAction: { padding: 8, borderRadius: 8 },
  btnQuick: { padding: 8, marginRight: 5 },
  footer: { flexDirection: "row", padding: 10 },
  footerBtn: {
    flex: 1,
    padding: 10,
    marginHorizontal: 5,
    borderRadius: 12,
    alignItems: "center"
  },
  footerBtnText: { color: "white", fontWeight: "bold", fontSize: 12 },
  modalOverlay: {
    flex: 1,
    backgroundColor: "rgba(0,0,0,0.8)",
    justifyContent: "center",
    alignItems: "center",
  },
  modalContent: { width: "85%", padding: 25, borderRadius: 20 },
  modalTitle: { fontSize: 18, fontWeight: "bold", marginBottom: 15 },
  modalInput: {
    padding: 15,
    borderRadius: 10,
    fontSize: 24,
    textAlign: "center",
    marginBottom: 20,
    borderWidth: 1,
  },
  modalActions: {
    flexDirection: "row",
    justifyContent: "flex-end",
    alignItems: "center",
  },
  btnConfirm: { paddingVertical: 10, paddingHorizontal: 20, borderRadius: 8 },
  refresh_icon: { marginLeft:60 }

});
